D__TPOINTLISTTHOC = 1
//see help file in neuron extention help pages (wiki)
// https://bbpteam.epfl.ch/wiki/index.php/NE:TPointList
load_file("./_classlib/TString.hoc","D__TSTRINGHOC") // For TString class used in secname_() method


begintemplate TPointList
	public append,each_point,count,sclst,point,points,access_,mark,each_point_var
	public setrand_distance, find
	objref sclst,x,null,this,rnd,marklist,sl,NULL,sec_list, tags
	strdef classname,tmp,style
	public classname,loc,setrand,relocate,printf,total_l,x,mark1,filter_by_distance
	public setrand_descrete, relocate_descrete,get_random_point,point,secname_,sec_list

	proc init(){
		classname="TPointList"
		sclst = new List()
		sec_list = new SectionList()
		tags = new List()
		x = new Vector()
		SPLIT = 0 //by default it will be only the local list
		gid = -1 //by default points do not have to belong to the same cell.
		if(numarg()>0) gid = $1
		if(numarg()>1) SPLIT = $2 //you will be able to set it to complete by the Manager objects

	}
	/**
     * Unified append: Routes all logic to append_internal.
     * Supports:
     * 1. append(x) or append(x, "tag")
     * 2. append(TPointList_Object)
     * 3. append("secname", x) or append("secname", x, "tag")
     */
    obfunc append() { local j localobj sl, tag
		//first deal with the tag
		tag = new TString("")
		if(numarg()>1) {
			if(argtype(2) == 1) tag = new TString($o2)
			if(argtype(2) == 2) tag = new TString($s2)
		}
		
		// Type 0 = Number (Standard append)
        if (argtype(1) == 0) append_internal($1, tag)
		// Type 1 = Object (Assume it's a TPointList to merge)
		if (argtype(1) == 1) { 
			sl = $o1.sclst
			for j = 0, sl.count() - 1 {
				// Shift context to the source section, then append
				sl.o(j).sec append_internal($o1.x.x[j], $o1.tags.o(j)) 
			}
		}
		return this
    }

    /**
     * Centralized Helper: Pushes the point, section reference, and tag into memory.
     * Assumes the correct section is currently accessed.
     */
    proc append_internal() { localobj sr
        x.append($1)
		sr = new SectionRef()
        sclst.append(sr)
        sr.sec sec_list.append() 
        // Initialize TString with the passed tag string
        if(numarg() > 1){
			tags.append(new TString($o2))
		} else {
			tags.append(new TString(""))
		}
    }

    /**
     * find: returns a new TPointList containing points matching the tag.
     */
    obfunc find() { local i localobj result
        result = new TPointList()
        for i = 0, tags.count() - 1 {
            if (strcmp(tags.o(i).s, $s1) == 0) {
                sclst.o(i).sec result.append(x.x[i], tags.o(i).s)
            }
        }
        return result
    }

	iterator each_point(){local i
		for i=0, sclst.count-1{
			if(sclst.o(i).exists) {
				sclst.o(i).sec{
					$&1 = x.x[i]
					iterator_statement
				}
			}else{
				if(SPLIT){
					$&1 = -1 //Prevent using this number as a section loc(x)
					iterator_statement
				}
			}
		}
	}



	//from here on some utility functions which make the use of this class more convinient
	iterator point(){
		sclst.o($1).sec{
			$&2 = x.x[$1]
			iterator_statement
		}
	}

	//use points, it make more sense to use it this way.s
	iterator points(){local i
		for i=2, numarg() sclst.o($i).sec{
			$&1 = x.x[$i]
			iterator_statement
		}
	}


	proc loc(){
		sclst.o($2).sec $o1.loc(x.x[$2])
	}


	func count(){
		return sclst.count
	}


	func access_(){
		sclst.o($1).sec sprint(tmp,"access %s",secname())
		execute(tmp)
		return x.x[$1]
	}

	proc mark(){local x,color,size localobj m
		{color = 1 style = "O" size = 6}
		if(numarg()>1) color = $2
		if(numarg()>2) style = $s3
		if(numarg()>3) size = $4
		if(marklist != NULL) for x=0,marklist.count - 1  $o1.point_mark_remove(marklist.o(x))
		marklist = new List() //kill the old lists

		for each_point(&x) {
			m = new PointProcessMark(x)
			marklist.append(m)//so they will not disappear with refresh
			$o1.point_mark(m,color,style,size)
		}
	}
	proc mark1(){local x,color,size localobj m
		{color = 1 style = "O" size = 6}
		if(numarg()>2) color = $3
		if(numarg()>3) style = $s4
		if(numarg()>4) size = $5
		marklist = new List() //kill the old lists

		for point($2,&x) {
			m = new PointProcessMark(x)
			marklist.append(m)//so they will not disappear with refresh
			$o1.point_mark(m,color,style,size)
		}
	}

	proc setrand(/*SectionList,point_count[,randobj]*/){local tl,l,i,k localobj vx
	//same seed every time - very important!!!! unless you use a stream
		rnd = new Random(123)
		sl = $o1  //set the class level object
		i = 1
		l = k = tl = 0
		if(numarg()>1) i = $2
		if(numarg()>2)rnd = $o3
		vx = new Vector(i)
		forsec sl tl+=L //get the total length of the section list
		total_l = tl
		rnd.uniform(0,tl)
		vx.setrand(rnd).sort()
		vx.append(1e80)//l will never be bigger than this value
		//note that no matter how many points there are, I am iterating only
		// once over section list!
		forsec sl {
			l+=L
			while(l>=vx.x[k]) {//go over all the possible in this section
				append(1 - (l-vx.x[k])/L)
				k+=1
			}
			if(k==i) break
		}
	}



	// proc setrand_distance(/*SectionList,distance,points_count,[,randobj]*/){local l,k,x,min_dist,points_countpoints_count
	// //same seed every time - very important!!!! unless you use a stream
	// // slow, but get you all the synapses above some distance from
	// // the last activation of distance(0) function
	// 	distance()
	// 	rnd = new Random(123)
	// 	sl = $o1  //set the class level object
	// 	min_dist = $2
	// 	points_count = 1
	// 	l = k = total_l = 0
	// 	if(numarg()>2) points_count = $3
	// 	if(numarg()>3)rnd = $o4
	// 	forsec sl total_l+=L //get the total length of the section list
	// 	total_l = total_l
	// 	rnd.uniform(0,total_l) //select a random point
	// 	while(k<points_count){
	// 		d = rnd.repick()
	// 		l = 0
	// 		//fprint ("\r%d synapses" , k)

	// 		forsec sl {
	// 			if(d > l && d < l + L){ //point is in this section
	// 				x = (d - l) / L // x posibion on the section
	// 				dist = distance(x)
	// 				if(dist > min_dist){//discard every point below dist_min.
	// 					append(x)
	// 					k+=1
	// 				}
	// 				break
	// 			}
	// 			l = l + L
	// 		}
	// 	}
	// }


	/**
     * Efficiently distributes points across sections that fall strictly within [min_dist, max_dist].
     * Assumes the origin section is currently on the stack (e.g., soma pl.setrand_distance(...)).
     * * Parameters:
     * $o1: SectionList
     * $2: min_dist (um)
     * $3: max_dist (um)
     * $4: points_count
     * $o5: (Optional) Random object
     */
    proc setrand_distance() { local d0, d1, dmin, dmax, target_dmin, target_dmax, x0, x1, l_valid, temp, k, total_valid_l, u, i, offset, seg_l, frac, final_x localobj sec_refs, valid_x0, valid_x1, cum_l, draw_vec
        
        // Establish the distance origin based on the currently accessed section
        distance()

        sl = $o1
        min_dist = $2
        max_dist = $3
        points_count = $4
        
        if (numarg() > 4) {
            rnd = $o5
        } else {
            rnd = new Random(123)
        }

        // Vectors to hold the exact coordinates of valid dendritic segments
        sec_refs = new List()
        valid_x0 = new Vector()
        valid_x1 = new Vector()
        cum_l = new Vector()

        total_valid_l = 0
        
        // Phase 1: Pre-compute valid segments (Single Pass)
        forsec sl {
            // Because distance() was called, this accurately measures from the origin section
            d0 = distance(0)
            d1 = distance(1)

            // Normalize min/max distance for this section
            if (d0 < d1) { 
                dmin = d0  
                dmax = d1 
            } else { 
                dmin = d1  
                dmax = d0 
            }

            // Check if section overlaps with the [min_dist, max_dist] requirement
            if (dmax >= min_dist && dmin <= max_dist) {
                target_dmin = min_dist
                if (dmin > min_dist) {
                    target_dmin = dmin
                }

                target_dmax = max_dist
                if (dmax < max_dist) {
                    target_dmax = dmax
                }

                // Map physical distances to normalized x coordinates [0, 1]
                if (d0 < d1) {
                    x0 = (target_dmin - d0) / (d1 - d0)
                    x1 = (target_dmax - d0) / (d1 - d0)
                } else {
                    x0 = (d0 - target_dmin) / (d0 - d1)
                    x1 = (d0 - target_dmax) / (d0 - d1)
                }

                // Safety clamp to ensure we stay within section bounds
                if (x0 < 0) { x0 = 0 }
                if (x1 > 1) { x1 = 1 }
                if (x0 > x1) { 
                    temp = x0  
                    x0 = x1  
                    x1 = temp 
                }

                l_valid = (x1 - x0) * L
                
                // If there is valid length, record it
                if (l_valid > 0) {
                    sec_refs.append(new SectionRef())
                    valid_x0.append(x0)
                    valid_x1.append(x1)
                    total_valid_l += l_valid
                    cum_l.append(total_valid_l)
                }
            }
        }

        // Safety catch to prevent infinite loops / crashes
        if (total_valid_l <= 0) {
            printf("Error (TPointList): No valid sections found within distance [%g, %g]\n", min_dist, max_dist)
            return
        }

        // Phase 2: Direct Sampling (Zero Rejections)
        rnd.uniform(0, total_valid_l)
        draw_vec = new Vector(points_count)
        draw_vec.setrand(rnd).sort()

        k = 0
        for i = 0, draw_vec.size()-1 {
            u = draw_vec.x[i]

            // Find which valid segment this random draw falls into
            while (u > cum_l.x[k] && k < cum_l.size()-1) {
                k += 1
            }

            // Calculate length offsets within the specific segment
            if (k == 0) {
                offset = u
                seg_l = cum_l.x[0]
            } else {
                offset = u - cum_l.x[k-1]
                seg_l = cum_l.x[k] - cum_l.x[k-1]
            }

            // Convert physical offset back into fractional x location
            frac = offset / seg_l
            final_x = valid_x0.x[k] + frac * (valid_x1.x[k] - valid_x0.x[k])

            // Append using the exact section context
            sec_refs.o(k).sec {
                append(final_x)
            }
        }
    }

	
	func get_random_point(/*[randobj]*/){local tl,l,i,k,x localobj vx
	//same seed every time - very important!!!! unless you use a stream
		l = k = tl = 0		
		rnd = $o1
		for each_point(&x) tl += L/nseg
		rnd.uniform(0,tl)
		k = rnd.repick()
		tl = i = 0
		for each_point(&x) {
			tl += L/nseg
			if(tl <= k) i+=1
		}
		return i
		
	}
	proc setrand_descrete(/*SectionList,point_count[,randobj]*/){local i,k,point_count,x,nnseg localobj vx
	//same seed every time - very important!!!! unless you use a stream
		rnd = new Random(123) 
		sl = $o1 //set the class level object
		k = i = 0		
		point_count = $2 
		if(numarg()>2)rnd = $o3
		nnseg = 0
		forsec sl nnseg+=nseg //get the total number of segments
		vx = new Vector(nnseg)
		rnd.uniform(0,1)
		vx = vx.setrand(rnd).apply("int").sortindex() //uniqe synapses location
		forsec sl {
			for(x,0){
				if(vx.x[k] == i) {
					append(x)
					k+=1
					print "i=",i
				}
				i+=1 //for the none-unique position case
				if(k>=point_count) break
			}
			if(k>=point_count) break
		}
	}
	
	
	proc relocate_descrete(){local i,point,x1
		i = 0
		point = $1
		k = $2
		forsec sl {
			for(x1,0){
				if(k==i){
					x.x[point] = x1
					sclst.remove(point) 
					sclst.insrt(point,new SectionRef())
				}
				i+=1
			}
			if(k<i) break
		}
		
	}
	
	proc relocate(){local l,li
		l = 0
		li = $2
		k = $1
		forsec sl {
			l+=L
			if(l>=li) {
				x.x[k] = 1 - (l-li)/L
				sclst.remove(k) 
				sclst.insrt(k,new SectionRef())
				break
			}
		}
		
	}
	
	//just make it simple when it is on the same section
	/*proc relocate(){
		x.x[$1] = $2
	}*/
	

	
	iterator each_point_var(){local i
		for i=0, sclst.count-1{
			if(sclst.o(i).exists) {
				sclst.o(i).sec{
					sprint($s2,"%s.%s(%g)",secname(),$s1,x.x[i])
					iterator_statement
				}
			}else{
				if(SPLIT){
					sprint($s2,"%s.%s(%g)",secname(),$s1,x.x[i])
					iterator_statement
				}
			}
		}
	}
	
	proc printf(){local x
		for each_point(&x) print secname(),"(",x,")"
	}
	
	obfunc secname_(){local x localobj s
		s = new TString()
		sclst.o($1).sec {s.append(secname())}
		return s
	}
endtemplate TPointList